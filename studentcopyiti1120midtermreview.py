# -*- coding: utf-8 -*-
"""StudentCopyITI1120MidtermReview.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G06ZM8cSeQu6pA2vh_gzRKErLYxHkkLy
"""



"""# Python Midterm Review
Fall, 29\10\2020

## Pedagogy
* Compressed time, so therefore the material we present may be compressed
* We want to teach what you want to know, so please ask questions.
* We're trying to keep the material as relevant to you as possible, so let us know if it's irrelevant or if there's more material you guys want to see
* Let us know if you just want to move to practice questions

## **Big O Notation**
* Big O notation is used to describe the time-efficiency of an algorithm
  * i.e Given a number of inputs $\textbf{n}$, how long will it take an algorithm to solve a problem in $\textbf{t}$ (milli)seconds\minutes\hours 

* Let $f$ and $g$ be real valued functions. $f(x),g(x) \in \mathbb{R} $ 
*$ f(x) = O(g(x))$ if there exists positive real numbers $c$ and $x_0$ such that $\mid f(x) \mid \leq c \cdot g(x)$  $\forall$ $ x \geq x_0$

![](https://drive.google.com/uc?export=view&id=1zhSaux1vJHjGmbVjjan9uJ9-pbMKrlhi)
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import time
import math
import os
from scipy.special import gamma
# %matplotlib inline

fig = plt.figure(figsize=(12,12),dpi = 75)
axes = fig.add_subplot(111)

x = np.linspace(1,5.5,1000)
y = np.linspace(1,5.5,1000)

plt.xticks(np.arange(min(x), max(x)+1, 1))

plt.plot(x,np.ones(1000), label = 'O(1)')
plt.plot(x,np.log2(x + 1), label = 'O(log(n))')
plt.plot(x,x, label = 'O(n)')
plt.plot(x,x*np.log2(x + 1), label = 'O(nlog(n))')
plt.plot(x,x**2, label = 'O(n²)')
plt.plot(x,2**x - 1,label = 'O(2ⁿ)')
plt.plot(x,gamma(x) * 3, label='O(n!)')

fig.legend()
# fig.plot()


fig.show()

"""### Cases
As with most things, algorithms behave differently or take a different amount of time based on the input and the content of the input
"""

import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
langs = ['Best', 'Average', 'Worst']
students = [10,20,30,]
ax.bar(langs,students)
plt.show()

#Example 1 - N runtime
x = [1,2,3,4,5,6,7,8,9,10,11]
n = len(x)
t = 0

print(x)

for i in range(n):
  t += 1
  x[i] += 2

print(x)
print(i)

#Example 2 - N^2 runtime
x = [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
n = len(x)
t = 0

print(x)

for i in range(n):
  for j in range
  t += 1
  x[i] += 2

print(x)
print(i)

"""### Practice Questions :"""

# Question 1 

n,m = 1000,1000
a,b = 0,0
for i in range(n):
  a += i

for i in range(m):
  b += i
  

# O(N * M) time, O(1) space
# O(N + M) time, O(N + M) space
# O(N + M) time, O(1) space -> Correct
# O(N * M) time, O(N + M) space

# Question 2

a = 0 
for i in range(n):
  for j in range(n,i,-1):
    a += i + j

# O(N)
# O(N*log(N))
# O(N * Sqrt(N))
# O(N*N) -> Correct

# Question 3

n = 20
ind = 0
k = 0
for i in range(n//2):
  for j in range(2,n,j*2):
    k += n/2

# O(n)
# O(nLogn) -> Correct
# O(n^2)
# O(n^2Logn)

# Question 4 

a,i = 0,1000
while(i > 0):
  a += i
  i/=2

# O(N)
# O(Sqrt(N))
# O(N / 2)
# O(log N) -> Correct

# Question 5 (Linear Search)

l = [1,2,3,6,4,9,10,12]
k = 12

for i in range(0, len(l)):
  if l[i] == k:
    print("Yes")
    break

"""---
## **Lists, Methods and Iteration**

---

  * Lists can be thought of as containers for objects. They hold one or more objects (they can be different types)
  * They can contain almost any object, including other lists (nested)
"""

#Simple Lists
a = [1,2,3,4,5,6]

#Lists can also contain objects of different types
person = [22, 160.24, 5, 0, 'Malik', 'Taylor'] #Age,Weight,Feet,Inches,First,Last

#Lists can also contain other lists among their types (more on that later)

"""### Indexing and Slicing
* Unlike tuples, lists are mutable, meaning that they can be changed and modified, and that they can be expanded
* Usually, most of these operations are handled by Python
* **Indexing** allows us to access a particular position in a list
  * In regular indexing, lists start at **0** and end at **n-1**
  * In negative indexing, lists start at **-n** and end at **-1**
* **Slicing** allows us to take a section of the list and return it as a list
* Let's look at some examples :
"""

#Indexing


#List indices start at 0 and end at n-1


#Lists can also be negative indexed (Starts at -1)

#Lists can be sliced. This returns a list subsection


#Lists can also be negative sliced

"""### List Methods
* There are methods that we can make use of to modify lists in python
* Remember, when doing these operations (save for copy,sorted, and reversed) we are modifying the list itself, not creating a new copy
* Pay attention to when you do and don't need a copy
"""

#Append -> Add an element to the end of the list


#Clear -> Remove all elements in a list

#Copy -> Creates a copy of a list (Slicing automatically creates a copy)


#Count -> Returns how many instances of an object happened in an array


#Extend -> Add the elements of one list to the end of another


#Index -> Returns the first index at which a certain element occurs


#Insert -> Insert element at specific location (negative indexing works too)


#Pop -> Removes the specified element of a list (negatice indexing works too)


#Remove -> Removes a specific element from the list


#Reverse -> Reverse the array 



#ALTERNATE : Reversed -> Does the same thing, however it returns a copy of the array


#Sort


#ALTERNATE : Sorted -> Does the same thing, however it returns a copy of the array

"""### Iteration
* Because they are sequential holders that can be indexed, it would be easier to loop over lists rather than type out individual commands repeatedly
* Loop types : 
  * For : deal with ranges and integers
  * While : deals with booleans, conditions and actions
"""

#For loops : 


#Object approach

"""While loops will continue to loop over the child commands until it's condition is no longer satisfactory



```
while CONDITION:
  print('running command')
```
"""

#example 1

#example 2:

#example 3:

"""the break operator can be used to terminate a while loop before it's condition has been met"""

#example 4

"""The continue operator reverts back to the top of the loop but doesn't completely break it"""

#example 5

"""---
## Strings and Text Based Methods 

---

*   Strings are simply arrays of bytes representing unicode characters

*   List item
"""

a = "Hello there."
length = len(a)

#Indexing (Uncomment Code)
# print(a[6])

#Slicing (Uncomment Code)
# print(a[0:5])

#Negative indexing (Uncomment Code)
# print(a[-1])
# print(a[-12])

#Negative Slicing
# print(a[-5:-1])
# print(a[3:-2])

#Resources for Anagram Finder
from google.colab import files
uploaded = files.upload()



#exmample 1 -> looping over a string

#example 2 -> looping over an array

#exmaple 3 -> double for loops

def squarefree(s):
    pass

"""### Up Monotone
* A sequence of numbers $\{x_1,x_2,x_3...\}$ is up-monotone when $\{x_1 < x_2 < x_3 < ... < x_n\} $
* Split an integer X (such as 12345678) into sections of size d
  * For example : $(X = 12345678, d = 2 ) \rightarrow ([12],[34],[56],[78] )$
"""

#Example 3 - Up Monotone

!ls

"""## Recursion
* I know it seems 'meta' and excessive for a function to call itself, but sometimes recursion offers elegant solutions, like in the case of Pell Numbers
$P = \begin{Bmatrix}0 & \text{if } n=0 \\
                    1 & \text{if } n=0 \\
                    2P_{n-1} + P_{n-1} & \text{if } n=0 \end{Bmatrix}$
* The point of emphasis is on the **base case(s)** (1 and 0 in this case)
  * These are the points at which your function will return
"""

#Pell Number

"""# IF AND ELSE



1.   Every if branch has to have 1 if statement
2.   Can have 0 -> infinite amount of elif statements
3.   0 - 1 else statements


*   Each if branch can only have 1 statement that prints out. After the first 
true condition is met. It will skip the remaining if statements
*   Else will only be reached if all other statements above return false
"""

